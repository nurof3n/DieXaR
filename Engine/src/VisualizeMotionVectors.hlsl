//*********************************************************
//
// VisualizeMotionVectors.hlsl
//
//*********************************************************

#define HLSL
#include "RaytracingHlslCompat.h"

// Input: The motion vector texture generated by the previous pass.
// Bound as a Shader Resource View (SRV).
Texture2D<float2> g_MotionVectors : register(t0);

// Output: A display-resolution texture to write the visualization to.
// Bound as an Unordered Access View (UAV).
RWTexture2D<float4> g_Output : register(u0);

[numthreads(8, 8, 1)]
void main(uint3 dispatchThreadID : SV_DispatchThreadID)
{
    // Read the motion vector for the current pixel.
    float2 motionVector = g_MotionVectors[dispatchThreadID.xy];

    // A multiplier to make the motion vectors more visible.
    // Motion vectors are in NDC space [-1, 1], so they can be small.
    // You can adjust this value to make motion more or less pronounced.
    float multiplier = 20.0f;

    // Map the X and Y components of the vector to the Red and Green color channels.
    // We add 0.5 to bias the color, so that no motion (0,0) results in a neutral gray.
    // - Positive X motion (right) will be reddish.
    // - Negative X motion (left) will be cyanish.
    // - Positive Y motion (down) will be greenish.
    // - Negative Y motion (up) will be purplish.
    float3 color = float3(motionVector.x * multiplier + 0.5, motionVector.y * multiplier + 0.5, 0.0);
    
    // Write the final color to the output texture.
    g_Output[dispatchThreadID.xy] = float4(saturate(color), 1.0);
}